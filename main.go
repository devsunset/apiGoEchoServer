/*
	########## dev ##########
	go install & path setting -> https://golang.org/
	EchoHigh performance, extensible, minimalist Go web framework
	https://echo.labstack.com/
	mkdir -p /workspace/devwork/apiServer
	cd /workspace/devwork/apiServer
	go mod init apiServer
	go get github.com/labstack/echo/v4
	go get github.com/labstack/echo/middleware
	go mod download golang.org/x/time
	coding main.go (swagger_apply_pre_main.go)
	https://pkg.go.dev/github.com/amarnus/echo-swagger#readme-echo-swagger
	go get github.com/swaggo/swag/cmd/swag
	cd /workspace/devwork/apiServer
	$GOPATH/go/bin/swag init (in project directory)
	go get -u github.com/swaggo/echo-swagger
	go mod download github.com/alecthomas/template
	go get github.com/alecthomas/template@v0.0.0-20190718012654-fb15b899a751
	coding main.go
        https://github.com/swaggo/swag#declarative-comments-format
*/
package main

import (
	"apiServer/db"
	_ "apiServer/docs" // docs is generated by Swag CLI, you have to import it.
	"fmt"
	"io"
	"net/http"
	"os"

	_ "github.com/lib/pq"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/swaggo/echo-swagger"
)

// @title apiServer  API
// @version 1.0
// @description This is a apiServer.

// @contact.name API Support
// @contact.url https://devsunset.github.io
// @contact.email devsunset@gmail.com

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host 193.123.252.22:8282
// @BasePath /
func main() {

	e := echo.New()

	e.GET("/", func(c echo.Context) error {
		return c.String(http.StatusOK, "Hello, World!")
	})

	//Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())
	e.Use(middleware.CORS())
	/*
		    To-Do
			e.Use(middleware.GzipWithConfig(middleware.GzipConfig{
				Level: 5,
			}))
	*/

	/* --- middleware sample ---
	// Group level middleware
	g := e.Group("/admin")
	g.Use(middleware.BasicAuth(func(username, password string, c echo.Context) (bool, error) {
		if username == "abc" && password == "123" {
			return true, nil
		}
		return false, nil
	}))

	// Route level middleware
	track := func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			println("request to /routemiddle")
			return next(c)
		}
	}

	e.GET("/routemiddle", func(c echo.Context) error {
		return c.String(http.StatusOK, "/routemiddle")
	}, track)
	*/

	// Routing
	e.GET("getLocationRegion", getLocationRegion)
	e.GET("getLocationCountry", getLocationCountry)
	e.GET("getLocationCity", getLocationCity)
	e.GET("getLocationType", getLocationType)
	e.GET("getLocation", getLocation)
	e.GET("/healthCheck", HealthCheck)

	e.GET("/getPathParameters/:id", getPathParameters)
	e.GET("/getQueryParameters", getQueryParameters)
	e.POST("postSave", postSave)
	e.POST("postSavefile", postSavefile)
	e.POST("users", users)

	// Static Content
	e.Static("static", "static")

	// Swagger
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	e.Logger.Fatal(e.Start(":8282"))
}

/////////////////////////////////////////////////////////////////

type Region struct {
	Region string `json:"region"`
}

type Regions struct {
	Regions []Region `json:"regions"`
}

// getLocationRegion godoc
// @Summary Tesla Chargers Location Region.
// @Description get tesla Chargers Location Region.
// @Tags API Tesla App
// @ID getLocationRegion
// @Accept */*
// @Produce json
// @Success 200 {object} Regions
// @Router /getLocationRegion [get]
func getLocationRegion(c echo.Context) error {

	db := db.DbManager()

	sqlStatement := "SELECT DISTINCT REGION FROM TB_TESLA_LOCATION"

	rows, err := db.Query(sqlStatement)
	if err != nil {
		fmt.Println(err)
		//	return c.JSON(http.StatusCreated, u)
	}

	defer rows.Close()
	defer db.Close()

	result := Regions{}

	for rows.Next() {
		region := Region{}
		err2 := rows.Scan(&region.Region)
		if err2 != nil {
			return err2
		}
		result.Regions = append(result.Regions, region)
	}
	return c.JSON(http.StatusCreated, result)
}

type Country struct {
	Country string `json:"country"`
}

type Countrys struct {
	Countrys []Country `json:"countrys"`
}

// getLocationCountry godoc
// @Summary Tesla Chargers Location Country.
// @Description get tesla Chargers Location Country.
// @Tags API Tesla App
// @ID getLocationCountry
// @Accept */*
// @Produce json
// @Param region query string false "asia_pacific"
// @Success 200 {object} Countrys
// @Router /getLocationCountry [get]
func getLocationCountry(c echo.Context) error {

	db := db.DbManager()

	region := c.QueryParam("region")

	sqlStatement := "SELECT DISTINCT COUNTRY FROM TB_TESLA_LOCATION WHERE 1=1 "

	if len(region) > 0 {
		sqlStatement += " AND REGION =  '" + region + "'"
	}

	rows, err := db.Query(sqlStatement)
	if err != nil {
		fmt.Println(err)
		//	return c.JSON(http.StatusCreated, u)
	}

	defer rows.Close()
	defer db.Close()

	result := Countrys{}

	for rows.Next() {
		country := Country{}
		err2 := rows.Scan(&country.Country)
		if err2 != nil {
			return err2
		}
		result.Countrys = append(result.Countrys, country)
	}
	return c.JSON(http.StatusCreated, result)
}

type City struct {
	City string `json:"City"`
}

type Citys struct {
	Citys []City `json:"Citys"`
}

// getLocationCity godoc
// @Summary Tesla Chargers Location City.
// @Description get tesla Chargers Location City.
// @Tags API Tesla App
// @ID getLocationCity
// @Accept */*
// @Produce json
// @Param country query string false "South Korea"
// @Success 200 {object} Citys
// @Router /getLocationCity [get]
func getLocationCity(c echo.Context) error {

	db := db.DbManager()

	country := c.QueryParam("country")

	sqlStatement := "SELECT DISTINCT CITY FROM TB_TESLA_LOCATION WHERE 1=1 "

	if len(country) > 0 {
		sqlStatement += " AND COUNTRY =  '" + country + "'"
	}

	rows, err := db.Query(sqlStatement)
	if err != nil {
		fmt.Println(err)
		//	return c.JSON(http.StatusCreated, u)
	}

	defer rows.Close()
	defer db.Close()

	result := Citys{}

	for rows.Next() {
		City := City{}
		err2 := rows.Scan(&City.City)
		if err2 != nil {
			return err2
		}
		result.Citys = append(result.Citys, City)
	}
	return c.JSON(http.StatusCreated, result)
}

type Location_type struct {
	Location_type string `json:"Location_type"`
}

type Location_types struct {
	Location_types []Location_type `json:"Location_types"`
}

// getLocationType godoc
// @Summary Tesla Chargers Location Type.
// @Description get tesla Chargers Location Type.
// @Tags API Tesla App
// @ID getLocationType
// @Accept */*
// @Produce json
// @Param country query string false "South Korea"
// @Param city query string false "서울특별시"
// @Success 200 {object} Location_types
// @Router /getLocationType [get]
func getLocationType(c echo.Context) error {

	db := db.DbManager()

	country := c.QueryParam("country")

	city := c.QueryParam("city")

	sqlStatement := "SELECT DISTINCT (unnest(string_to_array(LOCATION_TYPE, '|'))) AS LOCATION_TYPE FROM TB_TESLA_LOCATION where  1=1 "

	if len(country) > 0 {
		sqlStatement += " AND COUNTRY =  '" + country + "'"
	}

	if len(city) > 0 {
		sqlStatement += " AND CITY =  '" + city + "'"
	}

	sqlStatement += " ORDER BY 1 DESC"

	rows, err := db.Query(sqlStatement)
	if err != nil {
		fmt.Println(err)
		//	return c.JSON(http.StatusCreated, u)
	}

	defer rows.Close()
	defer db.Close()

	result := Location_types{}

	for rows.Next() {
		Location_type := Location_type{}
		err2 := rows.Scan(&Location_type.Location_type)
		if err2 != nil {
			return err2
		}
		result.Location_types = append(result.Location_types, Location_type)
	}
	return c.JSON(http.StatusCreated, result)
}

type Location struct {
	Sl_translate             string `json:"sl_translate"`
	Address_line_1           string `json:"address_line_1"`
	Address_line_2           string `json:"address_line_2"`
	Address_notes            string `json:"address_notes"`
	Address                  string `json:"address"`
	Amenities                string `json:"amenities"`
	Baidu_lat                string `json:"baidu_lat"`
	Baidu_lng                string `json:"baidu_lng"`
	Chargers                 string `json:"chargers"`
	City                     string `json:"city"`
	Common_name              string `json:"common_name"`
	Country                  string `json:"country"`
	Destination_charger_logo string `json:"destination_charger_logo"`
	Destination_website      string `json:"destination_website"`
	Directions_link          string `json:"directions_link"`
	Emails                   string `json:"emails"`
	Geocode                  string `json:"geocode"`
	Hours                    string `json:"hours"`
	Is_gallery               string `json:"is_gallery"`
	Kiosk_pin_x              string `json:"kiosk_pin_x"`
	Kiosk_pin_y              string `json:"kiosk_pin_y"`
	Kiosk_zoom_pin_x         string `json:"kiosk_zoom_pin_x"`
	Kiosk_zoom_pin_y         string `json:"kiosk_zoom_pin_y"`
	Latitude                 string `json:"latitude"`
	Location_id              string `json:"location_id"`
	Location_type            string `json:"location_type"`
	Longitude                string `json:"longitude"`
	Nid                      string `json:"nid"`
	Open_soon                string `json:"open_soon"`
	Path                     string `json:"path"`
	Postal_code              string `json:"postal_code"`
	Province_state           string `json:"province_state"`
	Region                   string `json:"region"`
	Sales_phone              string `json:"sales_phone"`
	Sales_representative     string `json:"sales_representative"`
	Sub_region               string `json:"sub_region"`
	Title                    string `json:"title"`
	Trt_id                   string `json:"trt_id"`
	Created_dttm             string `json:"created_dttm"`
}

type Locations struct {
	Locations []Location `json:"locations"`
}

// getLocation godoc
// @Summary Tesla Chargers Location.
// @Description get tesla Chargers Location.
// @Tags API Tesla App
// @ID getLocation
// @Accept */*
// @Produce json
// @Param region query string false "asia_pacific"
// @Param country query string true "South Korea"
// @Param city query string false "서울특별시"
// @Param location_type query string false "supercharger"
// @Param nid query string false "28865"
// @Success 200 {object} Locations
// @Router /getLocation [get]
func getLocation(c echo.Context) error {

	db := db.DbManager()

	sqlStatement := `SELECT 
			  sl_translate, address_line_1, address_line_2, address_notes, address, amenities, baidu_lat, baidu_lng, chargers, city
			, common_name, country, destination_charger_logo, destination_website, directions_link, emails, geocode, hours, is_gallery
			, kiosk_pin_x, kiosk_pin_y, kiosk_zoom_pin_x, kiosk_zoom_pin_y, latitude, location_id, location_type, longitude, nid, open_soon
			, path, postal_code, province_state, region, sales_phone, sales_representative, sub_region, title, trt_id, created_dttm FROM tb_tesla_location WHERE 1=1 `

	region := c.QueryParam("region")

	country := c.QueryParam("country")

	city := c.QueryParam("city")

	location_type := c.QueryParam("location_type")

	nid := c.QueryParam("nid")

	if len(region) > 0 {
		sqlStatement += " AND REGION =  '" + region + "'"
	}

	if len(country) > 0 {
		sqlStatement += " AND COUNTRY =  '" + country + "'"
	}

	if len(city) > 0 {
		sqlStatement += " AND CITY =  '" + city + "'"
	}

	if len(location_type) > 0 {
		sqlStatement += " AND LOCATION_TYPE LIKE  '%" + location_type + "%'"
	}

	if len(nid) > 0 {
		sqlStatement += " AND NID =  '" + nid + "'"
	}

	rows, err := db.Query(sqlStatement)
	if err != nil {
		fmt.Println(err)
		//	return c.JSON(http.StatusCreated, u)
	}

	defer rows.Close()
	defer db.Close()

	result := Locations{}

	for rows.Next() {
		location := Location{}
		err2 := rows.Scan(&location.Sl_translate, &location.Address_line_1, &location.Address_line_2, &location.Address_notes, &location.Address, &location.Amenities, &location.Baidu_lat, &location.Baidu_lng, &location.Chargers, &location.City, &location.Common_name, &location.Country, &location.Destination_charger_logo, &location.Destination_website, &location.Directions_link, &location.Emails, &location.Geocode, &location.Hours, &location.Is_gallery, &location.Kiosk_pin_x, &location.Kiosk_pin_y, &location.Kiosk_zoom_pin_x, &location.Kiosk_zoom_pin_y, &location.Latitude, &location.Location_id, &location.Location_type, &location.Longitude, &location.Nid, &location.Open_soon, &location.Path, &location.Postal_code, &location.Province_state, &location.Region, &location.Sales_phone, &location.Sales_representative, &location.Sub_region, &location.Title, &location.Trt_id, &location.Created_dttm)
		if err2 != nil {
			return err2
		}
		result.Locations = append(result.Locations, location)
	}
	return c.JSON(http.StatusCreated, result)
}

// HealthCheck godoc
// @Summary Show the status of server.
// @Description get the status of server.
// @Tags API Tesla App
// @ID HealthCheck
// @Accept */*
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Router /healthCheck [get]
func HealthCheck(c echo.Context) error {
	return c.JSON(http.StatusOK, map[string]interface{}{
		"data": "Server is up and running",
	})
}

/////////////////////////////////////////////////////////////////
//
//	Example
//
/////////////////////////////////////////////////////////////////

// getPathParameters godoc
// @Summary  example get value from path
// @Description get value from path
// @Tags Example
// @ID getPathParameters
// @Accept */*
// @Produce plain
// @Param id path string true "1"
// @Success 200 {string} path param
// @Router /getPathParameters/{id} [get]
func getPathParameters(c echo.Context) error {
	// curl -GET http://localhost:8282/getPathParameters/1
	// Get value from path
	id := c.Param("id")
	return c.String(http.StatusOK, "id:"+id)
}

// getQueryParameters godoc
// @Summary  example get value from the query string
// @Description get value from the query string
// @Tags Example
// @ID  getQueryParameters
// @Accept */*
// @Produce plain
// @Param id query string true "1"
// @Param name query string true "2"
// @Success 200 {string} query param
// @Router /getQueryParameters [get]
func getQueryParameters(c echo.Context) error {
	// curl -GET http://localhost:8282/getQueryParameters?id=1&name=2
	// Get value from the query string
	id := c.QueryParam("id")
	name := c.QueryParam("name")
	return c.String(http.StatusOK, "id:"+id+", name:"+name)
}

// postSave godoc
// @Summary  example get value from the form
// @Description get value from the form
// @Tags Example
// @ID  postSave
// @Accept  application/x-www-form-urlencoded
// @Produce plain
// @Param id  formData string true "1"
// @Param name formData string true "2"
// @Success 200 {string} formData
// @Router /postSave [post]
func postSave(c echo.Context) error {
	// curl -F "id=1" -F "name=2"  http://localhost:8282/postSave
	// Get id and name
	// Form application/x-www-form-urlencoded
	id := c.FormValue("id")
	name := c.FormValue("name")
	return c.String(http.StatusOK, "id:"+id+", name:"+name)
}

// postSavefile godoc
// @Summary  example get value/file from the form
// @Description get value/file from the form
// @Tags Example
// @ID  postSavefile
// @Accept multipart/form-data
// @Produce plain
// @Param name formData string true "2"
// @Param avatar  formData file true "-"
// @Success 200 {string} formData
// @Router /postSavefile [post]
func postSavefile(c echo.Context) error {
	// curl -F "name=2" -F "avatar=@/path/to/your/avatar.txt" http://localhost:8282/postSavefile
	// Get name
	name := c.FormValue("name")
	// Get avatar
	avatar, err := c.FormFile("avatar")
	if err != nil {
		return err
	}
	// Source
	src, err := avatar.Open()
	if err != nil {
		return err
	}
	defer src.Close()
	// Destination
	dst, err := os.Create("upload/" + avatar.Filename)
	if err != nil {
		return err
	}
	defer dst.Close()
	// Copy
	if _, err = io.Copy(dst, src); err != nil {
		return err
	}
	return c.HTML(http.StatusOK, "<b>Thank you! "+name+"</b>")
}

type User struct {
	Id   string `json:"id" xml:"id" form:"id" query:"id"`
	Name string `json:"name" xml:"name" form:"name" query:"name"`
}

// users godoc
// @Summary  example get value from the form/json
// @Description get value from the form/json
// @Tags Example
// @ID  users
// @Accept  application/x-www-form-urlencoded
// @Produce json
// @Param id  formData string true "1"
// @Param name formData string true "2"
// @Success 200 {User} User
// @Router /users [post]
func users(c echo.Context) error {
	//curl -d '{"id":"1", "name":"2"}'  -H "Content-Type: application/json"  -X POST http://localhost:8282/users
	//Handling RequestBind json, xml, form or query payload into Go struct based on Content-Type request header.
	//Render response as json or xml with status code.
	u := new(User)
	if err := c.Bind(u); err != nil {
		return err
	}
	return c.JSON(http.StatusCreated, u)
	// or
	// return c.XML(http.StatusCreated, u)
}
